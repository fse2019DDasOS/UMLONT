/***************************************************************************************************
 * Copyright (c) 2003, 2007 IBM Corporation Licensed Material - Property of IBM. All rights
 * reserved.
 * 
 * US Government Users Restricted Rights - Use, duplication or disclosure v1.0 restricted by GSA ADP
 * Schedule Contract with IBM Corp.
 * 
 * Contributors: IBM Corporation - initial API and implementation
 **************************************************************************************************/
package com.ibm.ccl.soa.deploy.core.validator.constraints;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.MultiStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.SubMonitor;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.osgi.util.NLS;

import com.ibm.ccl.soa.deploy.core.Constraint;
import com.ibm.ccl.soa.deploy.core.CorePackage;
import com.ibm.ccl.soa.deploy.core.DeployCorePlugin;
import com.ibm.ccl.soa.deploy.core.DeployModelObject;
import com.ibm.ccl.soa.deploy.core.Unit;
import com.ibm.ccl.soa.deploy.core.constraint.AttributeValueConstraint;
import com.ibm.ccl.soa.deploy.core.constraint.BooleanOperator;
import com.ibm.ccl.soa.deploy.core.constraint.ShortConstraintDescriptor;
import com.ibm.ccl.soa.deploy.core.util.ConstraintUtil;
import com.ibm.ccl.soa.deploy.core.validator.ConstraintService;
import com.ibm.ccl.soa.deploy.core.validator.status.DeployCoreStatusFactory;
import com.ibm.ccl.soa.deploy.core.validator.status.DeployStatusIterator;
import com.ibm.ccl.soa.deploy.core.validator.status.IDeployStatus;
import com.ibm.ccl.soa.deploy.internal.core.DeployCoreMessages;

/**
 * Root abstract class for constraint validators.
 */
public abstract class ConstraintValidator {

	protected static List<ShortConstraintDescriptor> EMPTY_CONSTRAINT_LIST = Collections.emptyList();
	protected static IStatus CANCEL_STATUS = Status.CANCEL_STATUS;
	private static final String NULL_CAPTION = ""; //$NON-NLS-1$

	/**
	 * Answers the question whether this Validator is designed to validate the constraint.
	 * 
	 * @param constraint
	 *           constraint to validate.
	 * @return true or false
	 */
	public abstract boolean canValidateConstraint(Constraint constraint);

	/**
	 * Validates the constraint. If this validator is NOT designed to validate the constraint, it
	 * should return CANCEL_STATUS ({@link #CANCEL_STATUS}).
	 * 
	 * @param constraint
	 *           constraint to validate.
	 * @param context
	 *           the context in which the constraint should be validated.
	 * @param monitor
	 * @return the validation status. If this validator is NOT designed to validate the constraint,
	 *         it should return CANCEL_STATUS ({@link #CANCEL_STATUS}).
	 * 
	 * @see ConstraintUtil for useful utility methods.
	 */
	public abstract IStatus validate(Constraint constraint, DeployModelObject context,
			IProgressMonitor monitor);

	/**
	 * Validates the constraint. If this validator is NOT designed to validate the constraint, it
	 * should return CANCEL_STATUS ({@link #CANCEL_STATUS}). Also take as input IStatus generated
	 * by the validator(s) of the supertype constraints (if any).
	 * 
	 * Default implementation calls
	 * {@link #validate(Constraint, DeployModelObject, IProgressMonitor)} and collates the statuses.
	 * 
	 * @param constraint
	 *           constraint to validate.
	 * @param context
	 *           the context in which the constraint should be validated.
	 * @param monitor
	 * @param status
	 *           IStatus generated by the validator(s) of the supertype constraints (may be
	 *           MultiStatus or NULL).
	 * @return the validation status. If this validator is NOT designed to validate the constraint,
	 *         it should return CANCEL_STATUS ({@link #CANCEL_STATUS}).
	 * 
	 * @see ConstraintUtil for useful utility methods.
	 */
	public IStatus validate(Constraint constraint, DeployModelObject context,
			IProgressMonitor monitor, IStatus status) {
		// use old validate() method
		IStatus myStatus = validate(constraint, context, monitor);

		// shortcut
		if (status == null || status.isOK()) {
			return myStatus;
		}
		if (myStatus == null || myStatus.isOK()) {
			return status;
		}

		// compose status list
		List<IStatus> statusList = new ArrayList<IStatus>();
		if (status.isMultiStatus()) {
			for (Iterator<IDeployStatus> iter = new DeployStatusIterator(status); iter.hasNext();) {
				IDeployStatus cur = iter.next();
				statusList.add(cur);
			}
		} else {
			statusList.add(status);
		}
		if (myStatus.isMultiStatus()) {
			for (Iterator<IDeployStatus> iter = new DeployStatusIterator(myStatus); iter.hasNext();) {
				IDeployStatus cur = iter.next();
				statusList.add(cur);
			}
		} else {
			statusList.add(myStatus);
		}

		// make a single IStatus
		if (statusList.isEmpty()) {
			return DeployCoreStatusFactory.INSTANCE.getOKStatus();
		}
		if (statusList.size() == 1) {
			return statusList.get(0);
		}
		return new MultiStatus(DeployCorePlugin.PLUGIN_ID, 0, statusList
				.toArray(new IStatus[statusList.size()]),
				DeployCoreMessages.Model_consistency_status_message, null);
	}

	/**
	 * This method is an alternative version of validation that is used when the constraint
	 * participates in some external matching process (e.g., hosting link matching). For example,
	 * Requirement Expression is validated differently during the proper validation process and
	 * during the validation that participates in the hosting/dependency link matching. Default
	 * implementation returns OK status.
	 * 
	 * If this validator is NOT designed to validate the constraint, it should return CANCEL_STATUS ({@link #CANCEL_STATUS}).
	 * 
	 * @param constraint
	 *           constraint to validate.
	 * @param context
	 *           the context in which the constraint should be validated.
	 * @return validation status. If this validator is NOT designed to validate the constraint, it
	 *         should return CANCEL_STATUS ({@link #CANCEL_STATUS}).
	 * 
	 * @see ConstraintUtil for useful utility methods.
	 */
	public IStatus validateForPotentialMatch(Constraint constraint, DeployModelObject context) {
		if (canValidateConstraint(constraint)) {
			return DeployCoreStatusFactory.INSTANCE.getOKStatus();
		}
		return CANCEL_STATUS;
	}

	/**
	 * This method is an alternative version of validation that is used when the constraint
	 * participates in some external matching process (e.g., hosting link matching). For example,
	 * Requirement Expression is validated differently during the proper validation process and
	 * during the validation that participates in the hosting/dependency link matching. Default
	 * implementation returns OK status.
	 * 
	 * If this validator is NOT designed to validate the constraint, it should return CANCEL_STATUS ({@link #CANCEL_STATUS}).
	 * Also take as input IStatus generated by the validator(s) of the supertype constraints (if
	 * any).
	 * 
	 * Default implementation calls {@link #validateForPotentialMatch(Constraint, DeployModelObject)}
	 * and collates the statuses.
	 * 
	 * @param constraint
	 *           constraint to validate.
	 * @param context
	 *           the context in which the constraint should be validated.
	 * @param status
	 *           IStatus generated by the validator(s) of the supertype constraints (may be
	 *           MultiStatus or NULL).
	 * @return validation status. If this validator is NOT designed to validate the constraint, it
	 *         should return CANCEL_STATUS ({@link #CANCEL_STATUS}).
	 * 
	 * @see ConstraintUtil for useful utility methods.
	 */
	public IStatus validateForPotentialMatch(Constraint constraint, DeployModelObject context,
			IStatus status) {
		// use old validateForPotentialMatch() method
		IStatus myStatus = validateForPotentialMatch(constraint, context);

		// shortcut
		if (status == null || status.isOK()) {
			return myStatus;
		}
		if (myStatus == null || myStatus.isOK()) {
			return status;
		}

		// compose status list
		List<IStatus> statusList = new ArrayList<IStatus>();
		if (status.isMultiStatus()) {
			for (Iterator<IDeployStatus> iter = new DeployStatusIterator(status); iter.hasNext();) {
				IDeployStatus cur = iter.next();
				statusList.add(cur);
			}
		} else {
			statusList.add(status);
		}
		if (myStatus.isMultiStatus()) {
			for (Iterator<IDeployStatus> iter = new DeployStatusIterator(myStatus); iter.hasNext();) {
				IDeployStatus cur = iter.next();
				statusList.add(cur);
			}
		} else {
			statusList.add(myStatus);
		}

		// make a single IStatus
		if (statusList.isEmpty()) {
			return DeployCoreStatusFactory.INSTANCE.getOKStatus();
		}
		if (statusList.size() == 1) {
			return statusList.get(0);
		}
		return new MultiStatus(DeployCorePlugin.PLUGIN_ID, 0, statusList
				.toArray(new IStatus[statusList.size()]),
				DeployCoreMessages.Model_consistency_status_message, null);
	}

	/**
	 * The implementation should check that any of the potenital constraints can indeed be put as a
	 * child constraint of the given parentConstraint. It also checks the arity of child constraints
	 * and returns empty List ({@link #EMPTY_CONSTRAINT_LIST}) if no more children are allowed on
	 * the given constraint.
	 * 
	 * @param parentConstraint
	 *           the parent constraint
	 * @param potentialConstraints
	 *           the list of potential constraints to be put as a child to this constraint
	 * @return the filterd list of potential child constraints, based on the abilities and
	 *         preferences of the parentConstraint to have children; return value is a (non-strict)
	 *         subset of 'potentialConstraints'
	 */
	public List<ShortConstraintDescriptor> applicableConstraints(Constraint parentConstraint,
			List<ShortConstraintDescriptor> potentialConstraints) {
		return potentialConstraints;
	}

	/**
	 * The implementation should return the validation context DMO that the constraint will use to
	 * validate child constraints. Returns NULL, if this constraint validator can not validate this
	 * constraint instance, or if no child constraints are allowed.
	 * 
	 * Validator should implement this method, but may call
	 * {@link #getContextForChildConstraints_DefaultImpl} as a default implementation.
	 * 
	 * @param constraint
	 *           the constraint that that is being asked
	 * 
	 * @return returns the validation context DMO that the constraint will use to validate child
	 *         constraints. Returns null, if this constraint validator can not validate this
	 *         constraint or if no child constraints are allowed.
	 */
	public DeployModelObject getContextForChildConstraints(Constraint constraint) {
		return getContextForChildConstraints_DefaultImpl(constraint);
	}

	/**
	 * Default implementation of the {@link #getContextForChildConstraints} method. Validators may
	 * call this method when implementing the {@link #getContextForChildConstraints} method.
	 * 
	 * Corresponds to the default constraint behavior, when constraint passes its own validation
	 * context to its children, as their validation context.
	 * 
	 * @param constraint
	 *           the constraint that that is being asked
	 * 
	 * @return returns the validation context DMO that the constraint will use to validate child
	 *         constraints. Returns null, if this constraint validator can not validate this
	 *         constraint, or if no child constraints are allowed.
	 */
	protected DeployModelObject getContextForChildConstraints_DefaultImpl(Constraint constraint) {
		if (!canValidateConstraint(constraint)) {
			return null;
		}
		DeployModelObject parentDmo = constraint.getParent();
		if (parentDmo == null) {
			// parent is null, which is incorrect
			// TODO log an error?
			return null;
		}

		DeployModelObject context;
		if (parentDmo instanceof Constraint) {
			context = ConstraintService.INSTANCE.getContextForChildConstraints((Constraint) parentDmo);
		} else {
			// Parent is not a constraint, so the context is parent.
			context = parentDmo;
		}
		return context;
	}

	/**
	 * Returns one or several sets of child (or leaf) constraints on the given constraint that
	 * satisfy the overall constraint. The validation that is performed in the context may be
	 * relaxed, as if the validation has been performed for matching. The default implementation
	 * returns empty set, but constraint validators may override this method.
	 * 
	 * @param <T>
	 *           specific constraint type
	 * @param constraint
	 *           given constraint
	 * 
	 * @param context
	 *           validation context
	 * @return the list of lists of child (or leaf) constraints, if not empty; empty list otherwise,
	 *         never null.
	 */
	public <T extends Constraint> List<List<T>> getSatisfyingChildConstraintsForMatch(
			Constraint constraint, DeployModelObject context) {
		return Collections.emptyList();
	}

	/**
	 * Returns the title of the specified constraint.
	 * <p>
	 * The constraint is passed as an argument because "this" is not a reliable mechanism for context
	 * due to import topologies.
	 * <p>
	 * Does not contextualize the constraint description with the title of its child constraints.
	 * 
	 * @param constraint
	 *           the constraint whose title should be returned.
	 * @return the constraint title.
	 * @see #titleWithContext(Constraint)
	 * 
	 */
	public String title(Constraint constraint) {
		if (constraint == null) {
			return DeployCoreMessages.null_value;
		}
		String typeName = computeTypeName(constraint);
		String caption = constraint.getDisplayName();
		if (caption != null && !caption.trim().equals("")) { //$NON-NLS-1$
			//Type(caption)
			StringBuffer buf = new StringBuffer(typeName);
			buf.append(' ').append('(').append(caption.trim()).append(')');
			return buf.toString();
		}
		return typeName;
	}

	protected String computeTypeName(Constraint constraint) {
		String typeName = constraint.getEObject().eClass().getName();
		// Trim the "Constraint" part of the type name
		if (typeName.endsWith(CorePackage.Literals.CONSTRAINT.getName())) {
			int trimLength = CorePackage.Literals.CONSTRAINT.getName().length();
			if (typeName.length() > trimLength) {
				typeName = typeName.substring(0, typeName.length() - trimLength);
			}
		}
		return typeName;
	}

	/**
	 * Returns the title of the specified constraint in the context of its constraint childredn.
	 * <p>
	 * The constraint is passed as an argument because "this" is not a reliable mechanism for context
	 * due to import topologies.
	 * <p>
	 * Example: "hostname = 'foo'" + " " + " or " + "hostname = 'bar'" TODO generate method from XSD
	 * 
	 * @param constraint
	 *           the constraint whose contextual title should be returned.
	 * @return the constraint title in the context of its children.
	 * @see #title(Constraint)
	 */
	public String titleWithContext(Constraint constraint) {
		if (constraint == null) {
			return DeployCoreMessages.null_value;
		}
		if (constraint.getConstraints().size() == 0) {
			return title(constraint);
		}
		StringBuffer result = new StringBuffer();
		List<Constraint> stack = new LinkedList<Constraint>();
		stack.add(constraint);
		while (stack.size() > 0) {
			Constraint cur = stack.remove(0);
			stack.addAll(cur.getConstraints());
			int depth = childConstraintDepth(constraint, cur);
			if (result.length() > 0) {
				result.append(Character.LINE_SEPARATOR);
			}
			for (int i = 0; i < depth; i++) {
				result.append("  "); //$NON-NLS-1$
			}
			result.append(ConstraintService.INSTANCE.title(cur));
		}
		return result.toString();
	}

	/**
	 * Returns the number of containment levels in which the child constraint is nested.
	 * 
	 * @param parent
	 *           the parent constraint.
	 * @param child
	 *           the child constraint.
	 * @return the nesting levels, or -1 if no containment was found.
	 */
	protected int childConstraintDepth(Constraint parent, Constraint child) {
		if (parent == null || child == null) {
			return -1;
		}
		DeployModelObject o = child;
		int depth = 0;
		while (o != null && o instanceof Constraint && !o.equals(parent)) {
			o = o.getParent();
			depth++;
		}

		if (o == null || !o.equals(parent)) {
			return -1;
		}
		return depth;
	}

	protected String getAttributeName(AttributeValueConstraint avc) {
		String an = avc.getAttributeName();
		return an == null || an.trim().equals("") ? "<AttrName>" : an; //$NON-NLS-1$ //$NON-NLS-2$
	}

	protected String computeCaptionTitle(Constraint constraint) {
		if (constraint == null) {
			return NULL_CAPTION;
		}
		String title = constraint.getDisplayName();
		return title == null ? NULL_CAPTION : title;
	}

	protected String describe(Constraint constraint) {
		String combined = null;
		List constraints = constraint.getConstraints();
		if (constraint instanceof BooleanOperator) {
			String booleanOperator = ConstraintService.INSTANCE.title(constraint);
			for (Iterator iterator = constraints.iterator(); iterator.hasNext();) {
				Constraint child = (Constraint) iterator.next();
				String childCaption = ConstraintService.INSTANCE.title(child);
				if (combined == null) {
					combined = childCaption;
				} else {
					combined = combined + " " + booleanOperator + " " + childCaption; //$NON-NLS-1$ //$NON-NLS-2$
				}
			}
			return combined;
		} else {

			String caption = NLS.bind(DeployCoreMessages.RealizationConstraintValidator_0_,
					ConstraintService.INSTANCE.title(constraint));
			for (Iterator iterator = constraints.iterator(); iterator.hasNext();) {
				Constraint child = (Constraint) iterator.next();
				String childCaption = describe(child);
				if (combined == null) {
					combined = childCaption;
				} else if (iterator.hasNext()) {
					combined = NLS.bind(DeployCoreMessages.RealizationConstraintValidator_0_1_,
							new Object[] { combined, childCaption });
				} else {
					combined = NLS.bind(DeployCoreMessages.RealizationConstraintValidator_0_1__2,
							new Object[] { combined, childCaption });
				}
			}
			return NLS.bind(DeployCoreMessages.RealizationConstraintValidator_0_1__4, new Object[] {
					caption, combined });
		}
	}

	protected MultiStatus internalValidate(Constraint constraint, Unit unit, SubMonitor submonitor) {

		MultiStatus retval = new MultiStatus(DeployCorePlugin.PLUGIN_ID, 0, Status.OK_STATUS
				.getMessage(), null);
		submonitor.beginTask(unit.getCaptionProvider().title(unit), constraint.getConstraints()
				.size());
		try {
			for (Iterator iterator = constraint.getConstraints().iterator(); iterator.hasNext();) {
				Constraint childConstraint = (Constraint) iterator.next();
				IStatus status = ConstraintService.INSTANCE.validate(childConstraint, unit, submonitor
						.newChild(1));
				if (!status.isOK()) {
					retval.add(status);
				}

			}
		} finally {
			submonitor.done();
		}
		return retval;
	}

	/**
	 * TODO This method copied from PropertyUtils. We need to move it to a core utility class. The
	 * purpose is to have a consistent way to display EClass names, in the UI, command line
	 * responses, etc.
	 */
	protected String getDisplayEType(EClass ec, String valForNone) {
		if (ec != null) {
			EPackage ep = ec.getEPackage();
			String displayName = ep.getName() + '.' + ec.getName();
			return displayName;
		}

		return valForNone;
	}
}
